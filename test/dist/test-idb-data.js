(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test/test-idb-data.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../idb-keyval/dist/idb-keyval.mjs":
/*!*****************************************!*\
  !*** ../idb-keyval/dist/idb-keyval.mjs ***!
  \*****************************************/
/*! exports provided: Store, MultiStore, get, set, del, clear, keys */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiStore\", function() { return MultiStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"del\", function() { return del; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clear\", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\nconst promiseStore = (openreq, storeName) => new Promise((resolve, reject) => {\r\n    openreq.onerror = () => reject(openreq.error);\r\n    openreq.onsuccess = () => resolve(openreq.result);\r\n    // First time setup: create an empty object store\r\n    openreq.onupgradeneeded = () => {\r\n        openreq.result.createObjectStore(storeName);\r\n    };\r\n});\r\nclass Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = promiseStore(indexedDB.open(dbName), storeName);\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nclass MultiStore extends Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        super(dbName, storeName);\r\n        this.storeName = storeName;\r\n        this._dbup = this._dbp.then(db => {\r\n            if (db.objectStoreNames.contains(storeName))\r\n                return db;\r\n            db.close();\r\n            return promiseStore(indexedDB.open(dbName, db.version + 1), storeName);\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbup.then(() => super._withIDBStore(type, callback));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\n\n\n\n//# sourceURL=webpack:///../idb-keyval/dist/idb-keyval.mjs?");

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/assert/assert.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/intl-messageformat-parser/src/parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/intl-messageformat-parser/src/parser.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */(function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(elements) {\n                return {\n                    type    : 'messageFormatPattern',\n                    elements: elements,\n                    location: location()\n                };\n            },\n        peg$c1 = function(chunks) {\n                return chunks.reduce(function (all, chunk) {\n                    return all.concat(chunk)\n                }, []).join('')\n            },\n        peg$c2 = function(messageText) {\n                return {\n                    type : 'messageTextElement',\n                    value: messageText,\n                    location: location()\n                };\n            },\n        peg$c3 = /^[^ \\t\\n\\r,.+={}#]/,\n        peg$c4 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\", \",\", \".\", \"+\", \"=\", \"{\", \"}\", \"#\"], true, false),\n        peg$c5 = \"{\",\n        peg$c6 = peg$literalExpectation(\"{\", false),\n        peg$c7 = \",\",\n        peg$c8 = peg$literalExpectation(\",\", false),\n        peg$c9 = \"}\",\n        peg$c10 = peg$literalExpectation(\"}\", false),\n        peg$c11 = function(id, format) {\n                return {\n                    type  : 'argumentElement',\n                    id    : id,\n                    format: format && format[2],\n                    location: location()\n                };\n            },\n        peg$c12 = \"number\",\n        peg$c13 = peg$literalExpectation(\"number\", false),\n        peg$c14 = \"date\",\n        peg$c15 = peg$literalExpectation(\"date\", false),\n        peg$c16 = \"time\",\n        peg$c17 = peg$literalExpectation(\"time\", false),\n        peg$c18 = function(type, style) {\n                return {\n                    type : type + 'Format',\n                    style: style && style[2],\n                    location: location()\n                };\n            },\n        peg$c19 = \"plural\",\n        peg$c20 = peg$literalExpectation(\"plural\", false),\n        peg$c21 = function(pluralStyle) {\n                return {\n                    type   : pluralStyle.type,\n                    ordinal: false,\n                    offset : pluralStyle.offset || 0,\n                    options: pluralStyle.options,\n                    location: location()\n                };\n            },\n        peg$c22 = \"selectordinal\",\n        peg$c23 = peg$literalExpectation(\"selectordinal\", false),\n        peg$c24 = function(pluralStyle) {\n                return {\n                    type   : pluralStyle.type,\n                    ordinal: true,\n                    offset : pluralStyle.offset || 0,\n                    options: pluralStyle.options,\n                    location: location()\n                }\n            },\n        peg$c25 = \"select\",\n        peg$c26 = peg$literalExpectation(\"select\", false),\n        peg$c27 = function(options) {\n                return {\n                    type   : 'selectFormat',\n                    options: options,\n                    location: location()\n                };\n            },\n        peg$c28 = \"=\",\n        peg$c29 = peg$literalExpectation(\"=\", false),\n        peg$c30 = function(selector, pattern) {\n                return {\n                    type    : 'optionalFormatPattern',\n                    selector: selector,\n                    value   : pattern,\n                    location: location()\n                };\n            },\n        peg$c31 = \"offset:\",\n        peg$c32 = peg$literalExpectation(\"offset:\", false),\n        peg$c33 = function(number) {\n                return number;\n            },\n        peg$c34 = function(offset, options) {\n                return {\n                    type   : 'pluralFormat',\n                    offset : offset,\n                    options: options,\n                    location: location()\n                };\n            },\n        peg$c35 = peg$otherExpectation(\"whitespace\"),\n        peg$c36 = /^[ \\t\\n\\r]/,\n        peg$c37 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n        peg$c38 = peg$otherExpectation(\"optionalWhitespace\"),\n        peg$c39 = /^[0-9]/,\n        peg$c40 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c41 = /^[0-9a-f]/i,\n        peg$c42 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"]], false, true),\n        peg$c43 = \"0\",\n        peg$c44 = peg$literalExpectation(\"0\", false),\n        peg$c45 = /^[1-9]/,\n        peg$c46 = peg$classExpectation([[\"1\", \"9\"]], false, false),\n        peg$c47 = function(digits) {\n            return parseInt(digits, 10);\n        },\n        peg$c48 = /^[^{}\\\\\\0-\\x1F\\x7F \\t\\n\\r]/,\n        peg$c49 = peg$classExpectation([\"{\", \"}\", \"\\\\\", [\"\\0\", \"\\x1F\"], \"\\x7F\", \" \", \"\\t\", \"\\n\", \"\\r\"], true, false),\n        peg$c50 = \"\\\\\\\\\",\n        peg$c51 = peg$literalExpectation(\"\\\\\\\\\", false),\n        peg$c52 = function() { return '\\\\'; },\n        peg$c53 = \"\\\\#\",\n        peg$c54 = peg$literalExpectation(\"\\\\#\", false),\n        peg$c55 = function() { return '\\\\#'; },\n        peg$c56 = \"\\\\{\",\n        peg$c57 = peg$literalExpectation(\"\\\\{\", false),\n        peg$c58 = function() { return '\\u007B'; },\n        peg$c59 = \"\\\\}\",\n        peg$c60 = peg$literalExpectation(\"\\\\}\", false),\n        peg$c61 = function() { return '\\u007D'; },\n        peg$c62 = \"\\\\u\",\n        peg$c63 = peg$literalExpectation(\"\\\\u\", false),\n        peg$c64 = function(digits) {\n                return String.fromCharCode(parseInt(digits, 16));\n            },\n        peg$c65 = function(chars) { return chars.join(''); },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemessageFormatPattern();\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatPattern() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsemessageFormatElement();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsemessageFormatElement();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsemessageFormatElement() {\n      var s0;\n\n      s0 = peg$parsemessageTextElement();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseargumentElement();\n      }\n\n      return s0;\n    }\n\n    function peg$parsemessageText() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsechars();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsechars();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsews();\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsemessageTextElement() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsemessageText();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseargument() {\n      var s0, s1, s2;\n\n      s0 = peg$parsenumber();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c3.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$c3.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseargumentElement() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseargument();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s6 = peg$c7;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c8); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseelementFormat();\n                  if (s8 !== peg$FAILED) {\n                    s6 = [s6, s7, s8];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s7 = peg$c9;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c11(s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseelementFormat() {\n      var s0;\n\n      s0 = peg$parsesimpleFormat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsepluralFormat();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseselectOrdinalFormat();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseselectFormat();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesimpleFormat() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c12) {\n        s1 = peg$c12;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c14) {\n          s1 = peg$c14;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c16) {\n            s1 = peg$c16;\n            peg$currPos += 4;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c7;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsechars();\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c18(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralFormat() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c19) {\n        s1 = peg$c19;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsepluralStyle();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c21(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseselectOrdinalFormat() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 13) === peg$c22) {\n        s1 = peg$c22;\n        peg$currPos += 13;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsepluralStyle();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c24(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseselectFormat() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c25) {\n        s1 = peg$c25;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseoptionalFormatPattern();\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parseoptionalFormatPattern();\n                }\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c27(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s2 = peg$c28;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsechars();\n      }\n\n      return s0;\n    }\n\n    function peg$parseoptionalFormatPattern() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselector();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c5;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c6); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemessageFormatPattern();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s6 = peg$c9;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c30(s2, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseoffset() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c31) {\n        s1 = peg$c31;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsenumber();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c33(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepluralStyle() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseoffset();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseoptionalFormatPattern();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseoptionalFormatPattern();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c34(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsews() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c36.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsews();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsews();\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsedigit() {\n      var s0;\n\n      if (peg$c39.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsehexDigit() {\n      var s0;\n\n      if (peg$c41.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        if (peg$c45.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsedigit();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsedigit();\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsechar() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      if (peg$c48.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c50) {\n          s1 = peg$c50;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c52();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c53) {\n            s1 = peg$c53;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c54); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c56) {\n              s1 = peg$c56;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c58();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c59) {\n                s1 = peg$c59;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c61();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c62) {\n                  s1 = peg$c62;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$currPos;\n                  s3 = peg$currPos;\n                  s4 = peg$parsehexDigit();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsehexDigit();\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsehexDigit();\n                      if (s6 !== peg$FAILED) {\n                        s7 = peg$parsehexDigit();\n                        if (s7 !== peg$FAILED) {\n                          s4 = [s4, s5, s6, s7];\n                          s3 = s4;\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s2 = input.substring(s2, peg$currPos);\n                  } else {\n                    s2 = s3;\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c64(s2);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsechars() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechar();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechar();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})());\n\n//# sourceURL=webpack:///./node_modules/intl-messageformat-parser/src/parser.js?");

/***/ }),

/***/ "./node_modules/intl-messageformat/lib/compiler.js":
/*!*********************************************************!*\
  !*** ./node_modules/intl-messageformat/lib/compiler.js ***!
  \*********************************************************/
/*! exports provided: default, StringFormat, PluralFormat, PluralOffsetString, SelectFormat, isSelectOrPluralFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringFormat\", function() { return StringFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PluralFormat\", function() { return PluralFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PluralOffsetString\", function() { return PluralOffsetString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectFormat\", function() { return SelectFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSelectOrPluralFormat\", function() { return isSelectOrPluralFormat; });\n/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Compiler = /** @class */ (function () {\n    function Compiler(locales, formats) {\n        this.locales = [];\n        this.formats = {\n            number: {},\n            date: {},\n            time: {}\n        };\n        this.pluralNumberFormat = null;\n        this.currentPlural = null;\n        this.pluralStack = [];\n        this.locales = locales;\n        this.formats = formats;\n    }\n    Compiler.prototype.compile = function (ast) {\n        this.pluralStack = [];\n        this.currentPlural = null;\n        this.pluralNumberFormat = null;\n        return this.compileMessage(ast);\n    };\n    Compiler.prototype.compileMessage = function (ast) {\n        var _this = this;\n        if (!(ast && ast.type === 'messageFormatPattern')) {\n            throw new Error('Message AST is not of type: \"messageFormatPattern\"');\n        }\n        var elements = ast.elements;\n        var pattern = elements\n            .filter(function (el) {\n            return el.type === 'messageTextElement' || el.type === 'argumentElement';\n        })\n            .map(function (el) {\n            return el.type === 'messageTextElement'\n                ? _this.compileMessageText(el)\n                : _this.compileArgument(el);\n        });\n        if (pattern.length !== elements.length) {\n            throw new Error('Message element does not have a valid type');\n        }\n        return pattern;\n    };\n    Compiler.prototype.compileMessageText = function (element) {\n        // When this `element` is part of plural sub-pattern and its value contains\n        // an unescaped '#', use a `PluralOffsetString` helper to properly output\n        // the number with the correct offset in the string.\n        if (this.currentPlural && /(^|[^\\\\])#/g.test(element.value)) {\n            // Create a cache a NumberFormat instance that can be reused for any\n            // PluralOffsetString instance in this message.\n            if (!this.pluralNumberFormat) {\n                this.pluralNumberFormat = new Intl.NumberFormat(this.locales);\n            }\n            return new PluralOffsetString(this.currentPlural.id, this.currentPlural.format.offset, this.pluralNumberFormat, element.value);\n        }\n        // Unescape the escaped '#'s in the message text.\n        return element.value.replace(/\\\\#/g, '#');\n    };\n    Compiler.prototype.compileArgument = function (element) {\n        var format = element.format, id = element.id;\n        if (!format) {\n            return new StringFormat(id);\n        }\n        var _a = this, formats = _a.formats, locales = _a.locales;\n        switch (format.type) {\n            case 'numberFormat':\n                return {\n                    id: id,\n                    format: new Intl.NumberFormat(locales, formats.number[format.style])\n                        .format\n                };\n            case 'dateFormat':\n                return {\n                    id: id,\n                    format: new Intl.DateTimeFormat(locales, formats.date[format.style])\n                        .format\n                };\n            case 'timeFormat':\n                return {\n                    id: id,\n                    format: new Intl.DateTimeFormat(locales, formats.time[format.style])\n                        .format\n                };\n            case 'pluralFormat':\n                return new PluralFormat(id, format.ordinal, format.offset, this.compileOptions(element), locales);\n            case 'selectFormat':\n                return new SelectFormat(id, this.compileOptions(element));\n            default:\n                throw new Error('Message element does not have a valid format type');\n        }\n    };\n    Compiler.prototype.compileOptions = function (element) {\n        var _this = this;\n        var format = element.format;\n        var options = format.options;\n        // Save the current plural element, if any, then set it to a new value when\n        // compiling the options sub-patterns. This conforms the spec's algorithm\n        // for handling `\"#\"` syntax in message text.\n        this.pluralStack.push(this.currentPlural);\n        this.currentPlural = format.type === 'pluralFormat' ? element : null;\n        var optionsHash = options.reduce(function (all, option) {\n            // Compile the sub-pattern and save it under the options's selector.\n            all[option.selector] = _this.compileMessage(option.value);\n            return all;\n        }, {});\n        // Pop the plural stack to put back the original current plural value.\n        this.currentPlural = this.pluralStack.pop();\n        return optionsHash;\n    };\n    return Compiler;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Compiler);\n// -- Compiler Helper Classes --------------------------------------------------\nvar Formatter = /** @class */ (function () {\n    function Formatter(id) {\n        this.id = id;\n    }\n    return Formatter;\n}());\nvar StringFormat = /** @class */ (function (_super) {\n    __extends(StringFormat, _super);\n    function StringFormat() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StringFormat.prototype.format = function (value) {\n        if (!value && typeof value !== 'number') {\n            return '';\n        }\n        return typeof value === 'string' ? value : String(value);\n    };\n    return StringFormat;\n}(Formatter));\n\nvar PluralFormat = /** @class */ (function () {\n    function PluralFormat(id, useOrdinal, offset, options, locales) {\n        this.id = id;\n        this.offset = offset;\n        this.options = options;\n        this.pluralRules = new Intl.PluralRules(locales, {\n            type: useOrdinal ? 'ordinal' : 'cardinal'\n        });\n    }\n    PluralFormat.prototype.getOption = function (value) {\n        var options = this.options;\n        var option = options['=' + value] ||\n            options[this.pluralRules.select(value - this.offset)];\n        return option || options.other;\n    };\n    return PluralFormat;\n}());\n\nvar PluralOffsetString = /** @class */ (function (_super) {\n    __extends(PluralOffsetString, _super);\n    function PluralOffsetString(id, offset, numberFormat, string) {\n        var _this = _super.call(this, id) || this;\n        _this.offset = offset;\n        _this.numberFormat = numberFormat;\n        _this.string = string;\n        return _this;\n    }\n    PluralOffsetString.prototype.format = function (value) {\n        var number = this.numberFormat.format(value - this.offset);\n        return this.string\n            .replace(/(^|[^\\\\])#/g, '$1' + number)\n            .replace(/\\\\#/g, '#');\n    };\n    return PluralOffsetString;\n}(Formatter));\n\nvar SelectFormat = /** @class */ (function () {\n    function SelectFormat(id, options) {\n        this.id = id;\n        this.options = options;\n    }\n    SelectFormat.prototype.getOption = function (value) {\n        var options = this.options;\n        return options[value] || options.other;\n    };\n    return SelectFormat;\n}());\n\nfunction isSelectOrPluralFormat(f) {\n    return !!f.options;\n}\n//# sourceMappingURL=compiler.js.map\n\n//# sourceURL=webpack:///./node_modules/intl-messageformat/lib/compiler.js?");

/***/ }),

/***/ "./node_modules/intl-messageformat/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/intl-messageformat/lib/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compiler */ \"./node_modules/intl-messageformat/lib/compiler.js\");\n/* harmony import */ var intl_messageformat_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! intl-messageformat-parser */ \"./node_modules/intl-messageformat-parser/src/parser.js\");\n/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* jslint esnext: true */\n\n\n// -- MessageFormat --------------------------------------------------------\nfunction resolveLocale(locales) {\n    if (typeof locales === 'string') {\n        locales = [locales];\n    }\n    try {\n        return Intl.NumberFormat.supportedLocalesOf(locales, {\n            // IE11 localeMatcher `lookup` seems to convert `en` -> `en-US`\n            // but not other browsers,\n            localeMatcher: 'best fit'\n        })[0];\n    }\n    catch (e) {\n        return MessageFormat.defaultLocale;\n    }\n}\nfunction formatPatterns(pattern, values) {\n    var result = '';\n    for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n        var part = pattern_1[_i];\n        // Exist early for string parts.\n        if (typeof part === 'string') {\n            result += part;\n            continue;\n        }\n        var id = part.id;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && id in values)) {\n            throw new FormatError(\"A value must be provided for: \" + id, id);\n        }\n        var value = values[id];\n        // Recursively format plural and select parts' option  which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if (Object(_compiler__WEBPACK_IMPORTED_MODULE_0__[\"isSelectOrPluralFormat\"])(part)) {\n            result += formatPatterns(part.getOption(value), values);\n        }\n        else {\n            result += part.format(value);\n        }\n    }\n    return result;\n}\nfunction mergeConfig(c1, c2) {\n    if (!c2) {\n        return c1;\n    }\n    return __assign({}, (c1 || {}), (c2 || {}), Object.keys(c1).reduce(function (all, k) {\n        all[k] = __assign({}, c1[k], (c2[k] || {}));\n        return all;\n    }, {}));\n}\nfunction mergeConfigs(defaultConfig, configs) {\n    if (!configs) {\n        return defaultConfig;\n    }\n    return Object.keys(defaultConfig).reduce(function (all, k) {\n        all[k] = mergeConfig(defaultConfig[k], configs[k]);\n        return all;\n    }, __assign({}, defaultConfig));\n}\nvar FormatError = /** @class */ (function (_super) {\n    __extends(FormatError, _super);\n    function FormatError(msg, variableId) {\n        var _this = _super.call(this, msg) || this;\n        _this.variableId = variableId;\n        return _this;\n    }\n    return FormatError;\n}(Error));\nvar MessageFormat = (function (message, locales, overrideFormats) {\n    if (locales === void 0) { locales = MessageFormat.defaultLocale; }\n    // Parse string messages into an AST.\n    var ast = typeof message === 'string' ? MessageFormat.__parse(message) : message;\n    if (!(ast && ast.type === 'messageFormatPattern')) {\n        throw new TypeError('A message must be provided as a String or AST.');\n    }\n    // Creates a new object with the specified `formats` merged with the default\n    // formats.\n    var formats = mergeConfigs(MessageFormat.formats, overrideFormats);\n    // Defined first because it's used to build the format pattern.\n    var locale = resolveLocale(locales || []);\n    // Compile the `ast` to a pattern that is highly optimized for repeated\n    // `format()` invocations. **Note:** This passes the `locales` set provided\n    // to the constructor instead of just the resolved locale.\n    var pattern = new _compiler__WEBPACK_IMPORTED_MODULE_0__[\"default\"](locales, formats).compile(ast);\n    // \"Bind\" `format()` method to `this` so it can be passed by reference like\n    // the other `Intl` APIs.\n    return {\n        format: function (values) {\n            try {\n                return formatPatterns(pattern, values);\n            }\n            catch (e) {\n                if (e.variableId) {\n                    throw new Error(\"The intl string context variable '\" + e.variableId + \"' was not provided to the string '\" + message + \"'\");\n                }\n                else {\n                    throw e;\n                }\n            }\n        },\n        resolvedOptions: function () {\n            return { locale: locale };\n        },\n        getAst: function () {\n            return ast;\n        }\n    };\n});\nMessageFormat.defaultLocale = 'en';\n// Default format options used as the prototype of the `formats` provided to the\n// constructor. These are used when constructing the internal Intl.NumberFormat\n// and Intl.DateTimeFormat instances.\nMessageFormat.formats = {\n    number: {\n        currency: {\n            style: 'currency'\n        },\n        percent: {\n            style: 'percent'\n        }\n    },\n    date: {\n        short: {\n            month: 'numeric',\n            day: 'numeric',\n            year: '2-digit'\n        },\n        medium: {\n            month: 'short',\n            day: 'numeric',\n            year: 'numeric'\n        },\n        long: {\n            month: 'long',\n            day: 'numeric',\n            year: 'numeric'\n        },\n        full: {\n            weekday: 'long',\n            month: 'long',\n            day: 'numeric',\n            year: 'numeric'\n        }\n    },\n    time: {\n        short: {\n            hour: 'numeric',\n            minute: 'numeric'\n        },\n        medium: {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        },\n        long: {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric',\n            timeZoneName: 'short'\n        },\n        full: {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric',\n            timeZoneName: 'short'\n        }\n    }\n};\nMessageFormat.__parse = intl_messageformat_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MessageFormat);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/intl-messageformat/lib/index.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/artist/commands.js":
/*!********************************!*\
  !*** ./src/artist/commands.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  format\n} = __webpack_require__(/*! ./message-formatting */ \"./src/artist/message-formatting.js\");\n\nconst {\n  input,\n  comment\n} = __webpack_require__(/*! ./inputs */ \"./src/artist/inputs.js\");\n\nconst asArray = __webpack_require__(/*! ../asArray */ \"./src/asArray.js\");\n\nconst dateid = __webpack_require__(/*! ../dateid */ \"./src/dateid.js\");\n\nconst {\n  isSystem\n} = __webpack_require__(/*! ../domain/symbols */ \"./src/domain/symbols.js\");\n\nfunction formSubmitCommandDetector(e) {\n  if (e.target.name !== \"command\") return;\n  const form = e.target.closest(\"form\");\n  if (!form) return;\n  form.dataset.command = Array.from(e.target.classList)[0];\n  form.dataset.command_cid = e.target.dataset.cid;\n}\n\nconst saveHandlers = {};\n\nfunction reifyIds(container) {\n  const inputs = container.querySelectorAll(\"input,select,textarea\");\n  const cid = dateid();\n\n  for (const input of inputs) {\n    input.setAttribute(\"name\", input.getAttribute(\"name\").replace(/^_\\//, `${cid}/`));\n  }\n\n  for (const ele of container.children) {\n    if (\"cid\" in ele.dataset) ele.dataset.cid = cid;\n  }\n\n  const buttons = container.querySelectorAll(\"button\");\n\n  for (const button of buttons) {\n    if (\"cid\" in button.dataset) button.dataset.cid = cid;\n  }\n}\n\nasync function formSubmitHandler(e) {\n  e.preventDefault();\n  const form = e.target;\n\n  if (form) {\n    const document = form.ownerDocument;\n    const {\n      classList\n    } = form;\n    const command = form.dataset.command;\n    form.dataset.command = null;\n    const commandCid = form.dataset.command_cid;\n    form.dataset.command_cid = null;\n\n    switch (command) {\n      case \"reveal\":\n        if (!classList.contains(\"populating\")) classList.add(\"populating\");\n        break;\n\n      case \"save\":\n        await saveHandlers[form.dataset.cid](form);\n        form.dispatchEvent(new CustomEvent(\"artist-refresh\", {\n          bubbles: true\n        }));\n        break;\n\n      case \"new-item\":\n        const template = form.querySelector(\"template.new-item\");\n        if (!template) throw new Error(\"No new item template\");\n        const ele = document.importNode(template.content, true);\n        reifyIds(ele);\n        template.parentNode.insertBefore(ele, template);\n        break;\n\n      case \"delete-new-item\":\n        Array.from(form.querySelectorAll(\".new-item\")).filter(i => i.dataset.cid === commandCid).forEach(ele => ele.remove());\n        break;\n\n      case \"cancel\":\n        classList.remove(\"populating\");\n        form.reset();\n        break;\n\n      default:\n        throw new Error(\"Unrecognised command - \" + command);\n    }\n  }\n}\n\nconst defaultShape = {\n  \"@type\": \"NodeShape\",\n  \"property\": [{\n    \"path\": \"name\",\n    \"dataType\": \"xsd:string\"\n  }]\n};\n\nfunction generateInputField(prop, maybeValues, fieldName) {\n  const opts = {\n    name: encodeURI(fieldName || prop.path),\n    label: prop.name,\n    readonly: prop.immutable,\n    value: maybeValues && maybeValues[prop.path]\n  };\n\n  switch (prop.dataType) {\n    case \"xsd:dateTimeStamp\":\n      return prop.immutable ? comment(\"date time stamp will be calculated\") : input({ ...opts,\n        inputType: \"datetime-local\"\n      });\n\n    default:\n      return input({ ...opts,\n        inputType: \"text\"\n      });\n  }\n}\n\nconst nodeShapeProps = schema => schema && schema[\"@type\"] === \"NodeShape\" ? asArray(schema.property) : defaultShape.property;\n\nconst generateDefaultSchemaFields = (schema, maybeValues, generateAlias) => nodeShapeProps(schema).filter(x => x).map(prop => `\n                ${comment(JSON.stringify(prop))}\n                ${generateInputField(prop, maybeValues, generateAlias && generateAlias(prop))}\n            `).join(\"\\n\");\n\nconst generateMemberSchemaFields = (schema, maybeValues, index) => generateDefaultSchemaFields(schema, maybeValues, x => `${index}/${x.path}`);\n\nconst generateNewMemberFieldsForIdMap = (schema, values) => `\n\n    <input name=\"@type\" type=\"hidden\" value=\"IdMap\" />\n    <template class=\"new-item\">\n        <div class=\"new-item\" data-cid=\"\">\n            ${generateMemberSchemaFields(schema, null, \"_\")}\n            <button name=\"command\" class=\"delete-new-item\" data-cid=\"\">Remove</button>\n        </div>\n    </template>\n    <button name=\"command\" class=\"new-item\">New</button>\n\n`;\n\nconst generateExistingMembersFieldsForIdMapMember = (schema, key, value) => generateMemberSchemaFields(schema, value, key);\n\nconst generateExistingMembersFieldsForIdMap = (schema, values) => Object.entries(values).filter(([key]) => key && !isSystem(key) && !key.startsWith(\"@\")).reduce((acc, [key, value]) => `${acc}${generateExistingMembersFieldsForIdMapMember(schema, key, value)}`, \"\");\n\nconst generateFieldsForIdMap = (schema, values) => generateNewMemberFieldsForIdMap(schema, values) + generateExistingMembersFieldsForIdMap(schema, values);\n\nfunction generateFieldsForSchemaAndTypes({\n  schema,\n  types,\n  values\n}) {\n  if (types && types.includes(\"IdMap\")) return generateFieldsForIdMap(schema, values);\n  return generateDefaultSchemaFields(schema, values);\n}\n\nfunction generateImmutableValue({\n  dataType\n}) {\n  switch (dataType) {\n    case \"xsd:dateTimeStamp\":\n      const dts = new Date().toISOString();\n      return dts.substring(0, 19) + dts.substr(-1, 1);\n\n    default:\n      return undefined;\n  }\n}\n\nfunction generateValues(schemaProperties) {\n  return schemaProperties.filter(prop => prop.immutable).reduce((obj, prop) => ({ ...obj,\n    [prop.path]: generateImmutableValue(prop)\n  }), {});\n}\n\nfunction buildEntry(previousValues, generatedValues, schemaProperties) {\n  return schemaProperties.reduce((obj, prop) => ({ ...obj,\n    [prop.path]: prop.immutable && prop.path in previousValues ? previousValues[prop.path] : generatedValues[prop.path]\n  }), {});\n}\n\nfunction buildSaveHandler(execute, schema, values) {\n  return async function (form) {\n    const formData = new FormData(form);\n    const schemaProperties = schema && schema.property || [];\n    const generatedValues = generateValues(schemaProperties);\n    const isIdMap = formData.get(\"@type\") === \"IdMap\";\n    const data = Array.from(formData).filter(([key]) => !key.startsWith(\"@\")).reduce((obj, [encodedKey, value]) => {\n      const key = decodeURI(encodedKey);\n\n      if (isIdMap) {\n        const slash = key.indexOf(\"/\");\n        const id = key.substring(0, slash);\n        const path = key.substring(slash + 1);\n        const schemaProp = schemaProperties.find(prop => prop.path === path);\n        const previousValues = values[id];\n        let entry = obj[id] || buildEntry(previousValues, generatedValues, schemaProperties);\n        if (schemaProp && !schemaProp.immutable) entry = { ...entry,\n          [path]: value\n        };\n        return { ...obj,\n          [id]: entry\n        };\n      } else {\n        return { ...obj,\n          [key]: value\n        };\n      }\n    }, {});\n    if (isIdMap) return await execute({ ...data\n    });else return await execute({ ...data,\n      ...generatedValues\n    });\n  };\n}\n\nfunction addSaveHandler({\n  cid,\n  document,\n  execute,\n  schema,\n  values\n}) {\n  saveHandlers[cid] = buildSaveHandler(execute, schema, values);\n  if (document.body.dataset.formSubmitHandlerInstalled) return;\n  document.body.addEventListener(\"click\", formSubmitCommandDetector);\n  document.body.addEventListener(\"submit\", formSubmitHandler);\n  document.body.dataset.formSubmitHandlerInstalled = true;\n}\n\nfunction addToIndex({\n  execute,\n  path,\n  document,\n  actionableFormat,\n  schema\n}) {\n  const cid = `add-to-index_${path}`;\n  addSaveHandler({\n    cid,\n    document,\n    execute,\n    schema\n  });\n  const variables = {\n    count: 1\n  };\n\n  const commandText = action => actionableFormat ? `${action} ${format(actionableFormat, variables)}` : action;\n\n  return `\n        <form class=\"add-to-index\" data-cid=\"${cid}\">\n\n            ${generateDefaultSchemaFields(schema)}\n            <button name=\"command\" class=\"reveal\">${commandText(\"Add\")}</button>\n            <button name=\"command\" class=\"save\">${commandText(\"Save\")}</button>\n            <button name=\"command\" class=\"cancel\">Cancel</button>\n\n        </form>\n    `;\n}\n\nfunction editValues({\n  execute,\n  path,\n  document,\n  schema,\n  types,\n  actionableFormat,\n  values\n}) {\n  const cid = `edit-values_${path}`;\n  addSaveHandler({\n    cid,\n    document,\n    execute,\n    schema,\n    values\n  });\n\n  const commandText = action => actionableFormat ? `${action} ${actionableFormat}` : action;\n\n  return `\n        <form class=\"edit-values\" data-cid=\"${cid}\">\n\n            ${generateFieldsForSchemaAndTypes({\n    schema,\n    types,\n    values\n  })}\n            <button name=\"command\" class=\"reveal\">${commandText(\"Edit\")}</button>\n            <button name=\"command\" class=\"save\">${commandText(\"Save\")}</button>\n            <button name=\"command\" class=\"cancel\">Cancel</button>\n\n        </form>\n    `;\n}\n\nmodule.exports = {\n  addToIndex,\n  editValues\n};\n\n//# sourceURL=webpack:///./src/artist/commands.js?");

/***/ }),

/***/ "./src/artist/index.js":
/*!*****************************!*\
  !*** ./src/artist/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  renderIndexCommands,\n  renderValuesCommands\n} = __webpack_require__(/*! ./render/command-renderer */ \"./src/artist/render/command-renderer.js\");\n\nconst {\n  renderViewValues\n} = __webpack_require__(/*! ./render/values-renderer */ \"./src/artist/render/values-renderer.js\");\n\nconst {\n  renderIndex\n} = __webpack_require__(/*! ./render/index-renderer */ \"./src/artist/render/index-renderer.js\");\n\nconst {\n  a,\n  div,\n  nav,\n  span\n} = __webpack_require__(/*! ./inputs */ \"./src/artist/inputs.js\");\n\nfunction renderMainNav(path) {\n  const hrefUp = path && path.length && `#${path.slice(0, -1).join(\" / \")}`;\n  return nav(a(\"#\", \"home\", span(\"name\", \"Home\")) + hrefUp ? a(hrefUp, \"up\", span(\"name\", \"Up\")) : \"\");\n}\n\nfunction renderView({\n  path,\n  view,\n  render,\n  document\n}) {\n  render([renderMainNav(path), renderViewValues({\n    path,\n    view,\n    document\n  }), renderValuesCommands({\n    path,\n    view,\n    document\n  }), renderIndex(view), renderIndexCommands({\n    path,\n    view,\n    document\n  })].join(\"\\n\\n\"));\n}\n\nfunction cleanFragment(window) {\n  if (window.document.location.href.endsWith(\"#\")) {\n    history.replaceState(null, document.title, window.location.pathname + window.location.search);\n  }\n}\n\nmodule.exports = {\n  async initialize({\n    user,\n    view,\n    window\n  }) {\n    console.log(view);\n    const document = window.document;\n    const container = document.querySelector(\"main\");\n\n    const render = html => container.innerHTML = html;\n\n    async function renderViewForPath(forceUpdate) {\n      const hashPath = document.location.hash.substring(1);\n      cleanFragment(window);\n\n      if (!forceUpdate) {\n        const viewPath = view.path.join(\"/\");\n        if (hashPath === viewPath) return;\n      }\n\n      const path = hashPath.split(\"/\").filter(x => x);\n      const targetView = await view.commands.nav.go(path);\n\n      if (!targetView) {\n        render(div(\"not-found\", \"Not found\"));\n      } else {\n        view = targetView;\n        renderView({\n          path,\n          view,\n          render,\n          document\n        });\n      }\n    }\n\n    window.addEventListener(\"hashchange\", renderViewForPath);\n    document.addEventListener(\"artist-refresh\", () => renderViewForPath(true));\n    renderView({\n      path: view.path.join(\"/\"),\n      view,\n      render,\n      document\n    });\n    renderViewForPath();\n  }\n\n};\n\n//# sourceURL=webpack:///./src/artist/index.js?");

/***/ }),

/***/ "./src/artist/inputs.js":
/*!******************************!*\
  !*** ./src/artist/inputs.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const nav = (content, maybeClass) => `<nav${maybeClass ? ` class=\"${maybeClass}\"` : \"\"}>${content}</nav>`;\n\nconst div = (className, content) => `<div ${className ? `class=\"${className}\"` : \"\"}>${content}</div>`;\n\nconst label = text => span(\"label\", text);\n\nconst labelledDiv = (className, labelText, value) => div(className, label(labelText) + span(\"value\", value));\n\nconst section = (className, labelText, content) => `<section class=\"${className}\">${label(labelText)}${content}</section>`;\n\nconst span = (className, content) => `<span class=${className}>${content}</span>`;\n\nconst ul = lis => `<ul>${lis.join(\"\\n\")}</ul>`;\n\nconst li = (key, content) => `<li id=\"${key}\">${content}</li>`;\n\nconst comment = text => `<!-- ${text} -->`;\n\nconst img = (className, src) => `<img class=\"${className}\" src=\"${src}\" />`;\n\nconst labelledImg = (className, labelText, src) => labelledDiv(null, labelText, img(className, src));\n\nconst input = ({\n  name,\n  label,\n  inputType,\n  readonly,\n  value,\n  textValue\n}) => `<label>\n        ${span(\"label-text\", label)}\n        <input type=\"${readonly ? \"hidden\" : inputType}\" name=\"${name}\" ${value ? `value=\"${value}\"` : \"\"}\" />\n        ${readonly ? `<span class=\"readonly-text\">${textValue || value}</span>` : \"\"}\n    </label>`;\n\nconst a = (href, className, content) => `<a href=${href} class=\"${className}\">${content}</a>`;\n\nmodule.exports = {\n  a,\n  comment,\n  div,\n  img,\n  input,\n  labelledDiv,\n  labelledImg,\n  li,\n  nav,\n  section,\n  span,\n  ul\n};\n\n//# sourceURL=webpack:///./src/artist/inputs.js?");

/***/ }),

/***/ "./src/artist/message-formatting.js":
/*!******************************************!*\
  !*** ./src/artist/message-formatting.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"./node_modules/intl-messageformat/lib/index.js\").default;\n\nmodule.exports = {\n  format(format, params) {\n    return format && new IntlMessageFormat(format).format(params);\n  }\n\n};\n\n//# sourceURL=webpack:///./src/artist/message-formatting.js?");

/***/ }),

/***/ "./src/artist/render/command-renderer.js":
/*!***********************************************!*\
  !*** ./src/artist/render/command-renderer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  discriminator,\n  addToIndexCommand,\n  editValuesCommand,\n  sys\n} = __webpack_require__(/*! ../../domain/symbols */ \"./src/domain/symbols.js\");\n\nconst {\n  addToIndex,\n  editValues\n} = __webpack_require__(/*! ../commands */ \"./src/artist/commands.js\");\n\nconst {\n  nav\n} = __webpack_require__(/*! ../inputs */ \"./src/artist/inputs.js\");\n\nfunction renderIndexCommand({\n  path,\n  view,\n  command,\n  document\n}) {\n  if (!command) return \"\";\n  const actionableFormat = sys(view.values, \"actionable\");\n  const schema = command.schema;\n  const execute = command.execute.bind(command);\n\n  switch (command[discriminator]) {\n    case addToIndexCommand:\n      return addToIndex({\n        execute,\n        path,\n        schema,\n        document,\n        actionableFormat\n      });\n\n    default:\n      return \"\";\n  }\n}\n\nconst asArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : maybeArray ? [maybeArray] : [];\n\nfunction renderValuesCommand({\n  path,\n  view,\n  command,\n  document\n}) {\n  if (!command) return \"\";\n  const values = view.values || {};\n  const actionableFormat = sys(values, \"actionable\");\n  const schema = command.schema;\n  const execute = command.execute.bind(command);\n  const types = asArray(values[\"@type\"]);\n\n  switch (command[discriminator]) {\n    case editValuesCommand:\n      return editValues({\n        execute,\n        path,\n        schema,\n        document,\n        actionableFormat,\n        types,\n        values\n      });\n\n    default:\n      console.warn(\"Unknown\", command[discriminator]);\n  }\n}\n\nfunction renderCommands(commandsName, options) {\n  if (commandsName !== \"index\" && commandsName !== \"values\") throw new Error(`Out of range commandsName: ${commandsName}`);\n  const commands = options.view.commands[commandsName];\n  if (!(commands && commands.length)) return \"\";\n  const strategy = commandsName === \"index\" ? renderIndexCommand : renderValuesCommand;\n  const rendered = commands.map(command => strategy({ ...options,\n    command\n  })).filter(x => x).join(\"\\n\");\n  return rendered ? nav(rendered, `${commandsName}-commands`) : \"\";\n}\n\nmodule.exports = {\n  renderValuesCommands: options => renderCommands(\"values\", options),\n  renderIndexCommands: options => renderCommands(\"index\", options)\n};\n\n//# sourceURL=webpack:///./src/artist/render/command-renderer.js?");

/***/ }),

/***/ "./src/artist/render/index-renderer.js":
/*!*********************************************!*\
  !*** ./src/artist/render/index-renderer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  div,\n  nav\n} = __webpack_require__(/*! ../inputs */ \"./src/artist/inputs.js\");\n\nconst {\n  isSystem\n} = __webpack_require__(/*! ../../domain/symbols */ \"./src/domain/symbols.js\");\n\nconst renderIndex = view => view && view.index ? nav(Object.entries(view.index).filter(([key]) => !isSystem(key)).reduce((prev, [path, childView]) => `${prev}\n                    <a href=\"#${path}\" class=\"view\">\n                        ${childView.thumbnail ? `<img class=\"view-thumbnail\" src=\"${childView.thumbnail}\" />` : div(\"view-thumbnail-initial\", (childView.name || childView.path || \"?\").substr(0, 1))}<span class=\"name\">${childView.name || childView.path}</span>\n                    </a>`, \"\")) : \"\";\n\nmodule.exports = {\n  renderIndex\n};\n\n//# sourceURL=webpack:///./src/artist/render/index-renderer.js?");

/***/ }),

/***/ "./src/artist/render/values-renderer.js":
/*!**********************************************!*\
  !*** ./src/artist/render/values-renderer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  format\n} = __webpack_require__(/*! ../message-formatting */ \"./src/artist/message-formatting.js\");\n\nconst {\n  comment,\n  labelledDiv,\n  section,\n  labelledImg,\n  ul,\n  li\n} = __webpack_require__(/*! ../inputs */ \"./src/artist/inputs.js\");\n\nconst {\n  isSystem\n} = __webpack_require__(/*! ../../domain/symbols */ \"./src/domain/symbols.js\");\n\nconst {\n  renderIdMapValueCommands\n} = __webpack_require__(/*! ./command-renderer */ \"./src/artist/render/command-renderer.js\");\n\nfunction renderValue(key, value, params) {\n  switch (key) {\n    case \"name\":\n      return labelledDiv(key, \"Name\", format(value, params));\n\n    case \"thumbnail\":\n      return labelledImg(key, \"Thumbnail\", value);\n\n    case \"created\":\n      return labelledDiv(key, \"Created\", new Date(value));\n\n    case \"schema\":\n      return \"\";\n\n    case \"familyName\":\n      return labelledDiv(key, \"Last name\", value);\n\n    case \"givenName\":\n      return labelledDiv(key, \"First name\", value);\n\n    case \"jobTitle\":\n      return labelledDiv(key, \"Job\", value);\n\n    default:\n      if (key[0] === \"@\") return \"\";\n      return comment(`Unknown: ${key} ${JSON.stringify(value)}`);\n  }\n}\n\nconst isMeta = key => key && key.startsWith(\"@\");\n\nfunction renderIdMapValues(values, params) {\n  const items = Object.entries(values).filter(([key]) => key && !isMeta(key) && !isSystem(key)).map(([key, value]) => li(key, renderValues(value, params)));\n  return items && items.length ? ul(items) : \"\";\n}\n\nfunction renderValuesByType(values, params) {\n  let types = values[\"@type\"];\n  if (!types) return \"\";\n  types = Array.isArray(types) ? types : [types];\n  if (!types.length) return \"\";\n  if (types.includes(\"IdMap\")) return renderIdMapValues(values, params);\n  return \"\";\n}\n\nconst renderValuesByDefault = (values, params) => Object.entries(values).filter(([key]) => !isSystem(key)).map(([key, value]) => renderValue(key, value, params)).filter(x => x).join(\"\\n\");\n\nconst renderValues = (values, params) => renderValuesByType(values, params) || renderValuesByDefault(values, params);\n\nfunction renderViewValues({\n  path,\n  view,\n  documents\n}) {\n  if (!(view && view.values)) return \"\";\n  const params = {\n    indexCount: view.index ? Object.keys(view.index).length : 0,\n    commands: view.commands\n  };\n  const rendered = renderValues(view.values, params);\n  return rendered && section(\"values\", \"Values\", rendered);\n}\n\nmodule.exports = {\n  renderViewValues\n};\n\n//# sourceURL=webpack:///./src/artist/render/values-renderer.js?");

/***/ }),

/***/ "./src/asArray.js":
/*!************************!*\
  !*** ./src/asArray.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function asArray(maybeArray) {\n  if (Array.isArray(maybeArray)) return maybeArray;\n  return maybeArray == null ? [] : [maybeArray];\n};\n\n//# sourceURL=webpack:///./src/asArray.js?");

/***/ }),

/***/ "./src/data/data-acceptance-tests.js":
/*!*******************************************!*\
  !*** ./src/data/data-acceptance-tests.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const assert = polyfill(__webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\"));\n\nconst pruneKeys = __webpack_require__(/*! ../prune-keys */ \"./src/prune-keys.js\");\n\nmodule.exports = async function (store) {\n  console.log(\"\\n\", new Date(), \"\\n\");\n  let testContext = null;\n  store.configure({\n    initialize: x => {\n      testContext = x;\n    }\n  });\n  console.log(\" - Given login, test context user should equal \\\"dat-user\\\"\");\n  await store.login({\n    username: \"dat-user\"\n  });\n  assert.deepStrictEqual(testContext.user, {\n    username: \"dat-user\"\n  });\n  const {\n    root\n  } = testContext;\n  console.log(\" - Index should return null\");\n  assert.strictEqual((await root.index()), null);\n  console.log(\" - Add to index with non-object value should throw\");\n  await assert.rejects(() => root.addToIndex({\n    aboolean: false\n  }));\n  console.log(\" - Add to index with null object should throw\");\n  await assert.rejects(() => root.addToIndex({\n    anull: null\n  }));\n  console.log(\" - Add item to index, then index should return item\");\n  const a = await root.addToIndex({\n    ASG: {\n      name: \"andrew\"\n    }\n  });\n  assert.strictEqual(a.ASG.name, \"andrew\");\n  const b = await root.index();\n  assert.deepStrictEqual(Object.keys(b), [\"ASG\"]);\n  console.log(\" - Add item to index should return an index with navigable entries\");\n  const o = await a.ASG.go();\n  const o1 = await o.index();\n  assert.strictEqual(o1, null);\n  console.log(\" - Add duplicate item to index should throw\");\n  await assert.rejects(() => root.addToIndex({\n    ASG: {\n      oops: \"eee\"\n    }\n  }));\n  console.log(\" - Remove item from index, then index should no longer return item\");\n  const l = await root.index();\n  await root.addToIndex({\n    AMG: {\n      name: \"fomo\"\n    }\n  });\n  const l1 = await root.index();\n  assert.deepStrictEqual(Object.keys(l1).sort(), [\"ASG\", \"AMG\"].sort());\n  const l2 = await root.removeFromIndex(\"AMG\");\n  assert.deepStrictEqual(Object.keys(l2), [\"ASG\"]);\n  const l3 = await root.index();\n  assert.deepStrictEqual(Object.keys(l2), Object.keys(l3));\n  console.log(\" - Remove item from index, returned index should contain navigable entries\");\n  const n = await l2.ASG.go();\n  const n1 = await n.index();\n  assert.strictEqual(n1, null);\n  console.log(\" - Values should return null\");\n  assert.strictEqual((await root.values()), null);\n  console.log(\" - Remove values when there are no values should just return null\");\n  const m = await root.removeValues(\"oops\");\n  assert.strictEqual(m, null);\n  console.log(\" - Add item to values, then values should return item\");\n  const c = await root.setValues({\n    hello: \"world\"\n  });\n  assert.deepStrictEqual(c, {\n    hello: \"world\"\n  });\n  const d = await root.values();\n  assert.deepStrictEqual(d, {\n    hello: \"world\"\n  });\n  console.log(\" - Add another item to values, then values should return merged item\");\n  const e = await root.setValues({\n    goodbye: \"heaven\"\n  });\n  assert.deepStrictEqual(e, {\n    hello: \"world\",\n    goodbye: \"heaven\"\n  });\n  const f = await root.values();\n  assert.deepStrictEqual(f, {\n    hello: \"world\",\n    goodbye: \"heaven\"\n  });\n  console.log(\" - Set values with nothing should just return values\");\n  const q = await root.setValues(undefined);\n  assert.deepStrictEqual(q, f);\n  console.log(\" - Remove values should remove entries from the values\");\n  const g0 = await root.setValues({\n    x: \"y\"\n  });\n  assert.deepStrictEqual(g0, {\n    hello: \"world\",\n    goodbye: \"heaven\",\n    x: \"y\"\n  });\n  const g = await root.removeValues([\"hello\", \"x\"]);\n  assert.deepStrictEqual(g, {\n    goodbye: \"heaven\"\n  });\n  console.log(\" - Remove values with no keys specified should just return the values\");\n  const r = await root.removeValues();\n  assert.deepStrictEqual(r, g);\n  console.log(\" - Navigate to indexed item\");\n  const h0 = await root.index();\n  const h = await h0.ASG.go();\n  const i = await h.values();\n  const j0 = await h.setValues({\n    x: 1\n  });\n  const j = await h.values();\n  assert.deepStrictEqual(j0, j);\n  const k0 = await h.addToIndex({\n    JBG: {\n      name: \"Jonathan\"\n    },\n    SJ: {\n      name: \"Sarah-Jane\"\n    }\n  });\n  const k = await h.index();\n  assert.deepStrictEqual({\n    JBG: {\n      name: k0.JBG.name\n    }\n  }, {\n    JBG: {\n      name: k.JBG.name\n    }\n  });\n  assert.deepStrictEqual(Object.keys(k), Object.keys(k0));\n  console.log(\" - Navigate up to indexed item's parent\");\n  const s = await h.parent();\n  const svalues = await s.values();\n  const rootValues = await root.values();\n  assert.deepStrictEqual(svalues, rootValues);\n  console.log(\" - Attempt to naviate to root's parent should return undefined\");\n  const t = await root.parent();\n  assert(t === undefined);\n  console.log(\" - Update an index's values\");\n  const u = await root.addToIndex({\n    SJ: {\n      name: \"SJM\",\n      num: 1\n    }\n  });\n  assert(\"num\" in u.SJ);\n  const v = await root.updateIndex({\n    SJ: {\n      name: \"SJG\"\n    }\n  });\n  assert.strictEqual(v.SJ.name, \"SJG\");\n  assert(!(\"num\" in v.SJ));\n  const w = await root.index();\n  assert.deepStrictEqual(pruneKeys(v.SJ, x => x === \"go\"), pruneKeys(w.SJ, x => x === \"go\"));\n};\n\nfunction polyfill(maybeWebpackAssert) {\n  // polyfill for webpack\n  maybeWebpackAssert.rejects = maybeWebpackAssert.rejects || async function (func) {\n    try {\n      await func();\n    } catch (err) {\n      return err;\n    }\n\n    throw new Error(\"No exception was thrown\");\n  };\n\n  return maybeWebpackAssert;\n}\n\n//# sourceURL=webpack:///./src/data/data-acceptance-tests.js?");

/***/ }),

/***/ "./src/data/idb.js":
/*!*************************!*\
  !*** ./src/data/idb.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var idb_keyval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb-keyval */ \"../idb-keyval/dist/idb-keyval.mjs\");\nconst {\n  initialize\n} = __webpack_require__(/*! ../domain */ \"./src/domain/index.js\");\n\nconst schemaLoader = __webpack_require__(/*! ./schema-loader */ \"./src/data/schema-loader.js\");\n\n\n\nconst makePath = (prev, step) => `${prev}/${step}`;\n\nfunction series(store, namespace = \"\") {\n  const indexPath = `${namespace}__index`;\n  const valuesPath = `${namespace}__values`;\n\n  function decorateIndex(index) {\n    Object.entries(index).forEach(([key, values]) => {\n      values.go = () => series(store, makePath(namespace, key));\n    });\n  }\n\n  const loadIndex = async () => await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"get\"])(indexPath, store);\n\n  const saveIndex = async index => {\n    await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"set\"])(indexPath, index, store);\n    return await loadIndex();\n  };\n\n  const delIndexed = async key => {\n    await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"del\"])(makePath(namespace, key), store);\n    return await loadIndex();\n  };\n\n  const loadValues = async () => await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"get\"])(valuesPath, store);\n\n  const saveValues = async values => {\n    await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"set\"])(valuesPath, values, store);\n    return await loadValues();\n  };\n\n  async function updateIndex(hash, allowUpdates = false) {\n    if (!(hash && typeof hash === \"object\")) throw new Error(`Invalid key-value pairs to index: ${hash}`);\n    const index = (await loadIndex()) || {};\n    Object.entries(hash).forEach(([key, value]) => {\n      if (!allowUpdates && key in index) throw new Error(`Key already exists in this index: ${key}`);\n      if (typeof value !== \"object\") throw new Error(`Index value must be an object. ${key} is of type ${typeof value}: ${value}`);\n      if (!value) throw new Error(`Index value must be truthy. ${key} is ${value}`);\n      index[key] = value;\n    });\n    const updated = await saveIndex(index);\n    decorateIndex(updated);\n    return updated;\n  }\n\n  return {\n    async index() {\n      const index = await loadIndex();\n      if (!index) return null;\n      decorateIndex(index);\n      return index;\n    },\n\n    async addToIndex(hash) {\n      return await updateIndex(hash);\n    },\n\n    async updateIndex(hash) {\n      return await updateIndex(hash, true);\n    },\n\n    async removeFromIndex(keys) {\n      const index = (await loadIndex()) || {};\n      if (!(keys && keys.length)) return index;\n      if (!Array.isArray(keys)) keys = Array.from(arguments);\n      await Promise.all(keys.map(async key => {\n        if (key in index) delete index[key];\n        await delIndexed(key);\n      }));\n      const updated = await saveIndex(index);\n      decorateIndex(updated);\n      return updated;\n    },\n\n    async values() {\n      const values = await loadValues();\n      return values || null;\n    },\n\n    async setValues(hash) {\n      const values = await loadValues();\n      if (!hash) return values;\n      const updated = { ...values,\n        ...hash\n      };\n      return await saveValues(updated);\n    },\n\n    async removeValues(keys) {\n      const values = await loadValues();\n      if (!values) return values || null;\n      if (!(keys && keys.length)) return values;\n      keys.forEach(key => {\n        delete values[key];\n      });\n      return await saveValues(values);\n    },\n\n    async parent() {\n      if (!namespace) return undefined;\n      const lastIndexOfSlash = namespace && namespace.lastIndexOf(\"/\");\n      return series(store, namespace.substring(0, lastIndexOfSlash));\n    }\n\n  };\n}\n\nlet options;\n\nconst storeForUser = user => new idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"Store\"](`tc2-simple-teams__${user && user.username || \"shared\"}`, options.storeName || \"teams\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  configure(overrideOptions) {\n    if (overrideOptions) {\n      options = Object.assign(options || {}, overrideOptions);\n    } else {\n      options = overrideOptions;\n    }\n  },\n\n  // test seam\n  async purgeForUser(user) {\n    const store = storeForUser(user);\n    await Object(idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"clear\"])(store);\n  },\n\n  async login(user) {\n    const store = storeForUser(user);\n    window.i = {\n      store,\n      get: idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"get\"],\n      set: idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"set\"],\n      Store: idb_keyval__WEBPACK_IMPORTED_MODULE_0__[\"Store\"]\n    };\n    const teamsSeries = series(store);\n    const next = options && options.initialize || initialize;\n    next({\n      user,\n      root: teamsSeries,\n      schemaLoader,\n      options\n    });\n  }\n\n});\n\n//# sourceURL=webpack:///./src/data/idb.js?");

/***/ }),

/***/ "./src/data/schema-loader.js":
/*!***********************************!*\
  !*** ./src/data/schema-loader.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  sys\n} = __webpack_require__(/*! ../domain/symbols */ \"./src/domain/symbols.js\");\n\nmodule.exports = {\n  async fetchSchemaFor(doc) {\n    return sys(doc, \"schema\");\n  }\n\n};\n\n//# sourceURL=webpack:///./src/data/schema-loader.js?");

/***/ }),

/***/ "./src/dateid.js":
/*!***********************!*\
  !*** ./src/dateid.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\n  // thanks: https://gist.github.com/gordonbrander/2230317\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n};\n\n//# sourceURL=webpack:///./src/dateid.js?");

/***/ }),

/***/ "./src/domain/commands.js":
/*!********************************!*\
  !*** ./src/domain/commands.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const dateid = __webpack_require__(/*! ../dateid */ \"./src/dateid.js\");\n\nconst {\n  applyTemplate\n} = __webpack_require__(/*! ./templates */ \"./src/domain/templates.js\");\n\nconst pick = __webpack_require__(/*! ../pick */ \"./src/pick.js\");\n\nconst asArray = __webpack_require__(/*! ../asArray */ \"./src/asArray.js\");\n\nconst {\n  discriminator,\n  editValuesCommand,\n  addToIndexCommand,\n  sys,\n  asSystem\n} = __webpack_require__(/*! ./symbols */ \"./src/domain/symbols.js\");\n\nconst indexableProps = schema => schema && Array.isArray(schema.property) ? schema.property.filter(prop => prop.indexed).map(prop => prop.path) : [];\n\nasync function editValues(path, node, schemaLoader, values) {\n  const {\n    fetchSchemaFor\n  } = schemaLoader;\n  const schema = await fetchSchemaFor(values);\n  if (!schema) return null;\n  return {\n    [discriminator]: editValuesCommand,\n    schema,\n    execute: async values => {\n      console.log(\"Saving values\", values); // save values\n\n      await node.setValues(values); // find index\n\n      const parent = await node.parent(); // update index\n\n      const indexKey = path[path.length - 1];\n      const indexEntry = pick(values, indexableProps(schema));\n      if (Object.keys(indexEntry).length) await parent.updateIndex({\n        [indexKey]: indexEntry\n      });\n    }\n  };\n}\n\nasync function addToIndex(path, node, schemaLoader, index, values, options) {\n  const {\n    fetchSchemaFor\n  } = schemaLoader;\n  const template = sys(values, \"template\");\n  const schema = await fetchSchemaFor(template && template.values);\n  if (!schema) return null;\n  return {\n    [discriminator]: addToIndexCommand,\n    schema,\n    execute: async newValues => {\n      const nodeid = dateid();\n      const indexEntry = pick(newValues, indexableProps(schema)); // add entry to the index\n\n      const updatedIndex = await node.addToIndex({\n        [nodeid]: indexEntry\n      }); // get new node from the index\n\n      const newNode = await updatedIndex[nodeid].go();\n      const newValuesWithSchema = { ...newValues,\n        [asSystem(\"schema\")]: schema\n      };\n      const template = sys(values, \"template\");\n      const newIndex = template && template.index;\n      await applyTemplate(newNode, newIndex, newValuesWithSchema);\n    }\n  };\n}\n\nmodule.exports = {\n  async index(path, node, schemaLoader, index, values, options) {\n    const {\n      template\n    } = options;\n    const metadata = sys(index, \"metadata\");\n    const immutable = sys(metadata, \"immutable\");\n    return [!immutable && (await addToIndex(path, node, schemaLoader, index, values, template))].filter(x => x);\n  },\n\n  async values(path, node, schemaLoader, index, values, options) {\n    if (!values) return [];\n    return [await editValues(path, node, schemaLoader, values)].filter(x => x);\n  }\n\n};\n\n//# sourceURL=webpack:///./src/domain/commands.js?");

/***/ }),

/***/ "./src/domain/index.js":
/*!*****************************!*\
  !*** ./src/domain/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const artist = __webpack_require__(/*! ../artist */ \"./src/artist/index.js\");\n\nconst {\n  values: valuesCommands,\n  index: indexCommands\n} = __webpack_require__(/*! ./commands */ \"./src/domain/commands.js\");\n\nconst {\n  node: nodeNavigations,\n  entry: entryNavigations\n} = __webpack_require__(/*! ./navigations */ \"./src/domain/navigations.js\");\n\nconst symbols = __webpack_require__(/*! ./symbols */ \"./src/domain/symbols.js\");\n\nconst {\n  discriminator,\n  sys,\n  isSystem\n} = symbols;\n\nconst {\n  initializeFromTemplate\n} = __webpack_require__(/*! ./templates */ \"./src/domain/templates.js\");\n\nconst pick = __webpack_require__(/*! ../pick */ \"./src/pick.js\");\n\nmodule.exports = {\n  symbols,\n\n  async initialize({\n    user,\n    root,\n    schemaLoader,\n    options\n  }) {\n    const values = await root.values();\n    const metadata = sys(values, \"metadata\");\n\n    if (!(metadata && metadata.version)) {\n      await initializeFromTemplate(root, options);\n    }\n\n    const view = await buildView([], root, root, schemaLoader, options);\n    artist.initialize({\n      user,\n      view,\n      window: options.window\n    });\n  }\n\n};\n\nconst buildKey = bits => bits.join(\"/\");\n\nasync function buildView(path, node, root, schemaLoader, options) {\n  const values = await node.values();\n  const rawIndex = await node.index();\n\n  const buildViewForPathAndNode = (newPath, newNode) => buildView(newPath, newNode, root, schemaLoader, options);\n\n  const entryKey = key => buildKey([...path, key]);\n\n  function entryValue(key, value) {\n    if (typeof value !== \"object\") return undefined;\n    if (!value) return undefined;\n    const entryProps = Object.keys(value).filter(x => x !== \"go\");\n    return { ...pick(value, entryProps),\n      [discriminator]: key,\n      nav: entryNavigations(value, buildViewForPathAndNode)\n    };\n  }\n\n  const index = rawIndex ? Object.entries(rawIndex).filter(([key]) => !isSystem(key)).reduce((prev, [key, value]) => ({ ...prev,\n    [entryKey(key)]: entryValue(key, value)\n  }), {}) : null;\n  const commands = {\n    nav: await nodeNavigations(root, buildViewForPathAndNode),\n    values: await valuesCommands(path, node, schemaLoader, rawIndex, values, options),\n    index: await indexCommands(path, node, schemaLoader, rawIndex, values, options)\n  };\n  return {\n    path,\n    values,\n    index,\n    commands\n  };\n}\n\n//# sourceURL=webpack:///./src/domain/index.js?");

/***/ }),

/***/ "./src/domain/navigations.js":
/*!***********************************!*\
  !*** ./src/domain/navigations.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  node(root, buildViewForPathAndNode) {\n    return {\n      async go(path) {\n        path = Array.isArray(path) ? [...path] : [path];\n        let step = null;\n        let node = root;\n        const newPath = [];\n\n        while (step = path.shift()) {\n          const index = await node.index();\n          const indexStep = index[step];\n          if (!indexStep) return undefined;\n          node = await indexStep.go();\n          newPath.push(step);\n        }\n\n        return await buildViewForPathAndNode(newPath, node);\n      }\n\n    };\n  },\n\n  entry(value, buildViewForPathAndNode) {\n    return {\n      async go() {\n        const newNode = await value.go();\n        return await buildViewForPathAndNode([...path, key], newNode);\n      }\n\n    };\n  }\n\n};\n\n//# sourceURL=webpack:///./src/domain/navigations.js?");

/***/ }),

/***/ "./src/domain/symbols.js":
/*!*******************************!*\
  !*** ./src/domain/symbols.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const systemPrefix = \"otsv:\";\nmodule.exports = {\n  discriminator: Symbol(\"discriminator\"),\n  editValuesCommand: Symbol(\"edit-values-command\"),\n  addToIndexCommand: Symbol(\"add-to-index\"),\n\n  sys(obj, prop) {\n    return obj && obj[systemPrefix + prop];\n  },\n\n  asSystem(suffix) {\n    return systemPrefix + suffix;\n  },\n\n  isSystem(prop) {\n    return prop && prop.startsWith(systemPrefix);\n  }\n\n};\n\n//# sourceURL=webpack:///./src/domain/symbols.js?");

/***/ }),

/***/ "./src/domain/templates.js":
/*!*********************************!*\
  !*** ./src/domain/templates.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  sys,\n  isSystem,\n  asSystem\n} = __webpack_require__(/*! ./symbols */ \"./src/domain/symbols.js\");\n\nconst pruneKeys = __webpack_require__(/*! ../prune-keys */ \"./src/prune-keys.js\");\n\nasync function applyTemplate(node, indexTemplate, values) {\n  // set values for new node\n  if (values) await node.setValues(values); // index ?\n\n  if (!indexTemplate) return; // new index from template except for nested system properties\n\n  const indexEntries = Object.entries(indexTemplate).reduce((obj, [key, value]) => ({ ...obj,\n    [key]: isSystem(key) ? value : pruneKeys(value, x => isSystem(x))\n  }), {}); // create the index\n\n  const index = await node.addToIndex(indexEntries); // find any index entries which contain a nested template\n\n  const nestedTemplates = Object.entries(indexTemplate).filter(([, value]) => !!sys(value, \"nested-template\")).map(([key, value]) => [key, sys(value, \"nested-template\")]); // apply the nested templates\n\n  await Promise.all(nestedTemplates.map(async ([prop, nestedTemplate]) => {\n    // fetch the nested node\n    const nestedNode = await index[prop].go(); // apply the template\n\n    await applyTemplate(nestedNode, nestedTemplate.index, nestedTemplate.values);\n  }));\n}\n\nasync function initializeFromTemplate(node, {\n  template\n}) {\n  template = template || {};\n  await node.setValues({ ...template.values,\n    [asSystem(\"metadata\")]: {\n      version: template[\"@id\"] || \"unknown\",\n      template\n    }\n  });\n}\n\nmodule.exports = {\n  initializeFromTemplate,\n  applyTemplate\n};\n\n//# sourceURL=webpack:///./src/domain/templates.js?");

/***/ }),

/***/ "./src/pick.js":
/*!*********************!*\
  !*** ./src/pick.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = (obj, props) => props.reduce((x, prop) => ({ ...x,\n  [prop]: obj[prop]\n}), {});\n\n//# sourceURL=webpack:///./src/pick.js?");

/***/ }),

/***/ "./src/prune-keys.js":
/*!***************************!*\
  !*** ./src/prune-keys.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function pruneKeys(obj, isPruned) {\n  if (!(obj && typeof obj === \"object\")) return obj;\n  return Object.entries(obj).filter(([key]) => !isPruned(key)).reduce((pruned, [key, value]) => ({ ...pruned,\n    [key]: value\n  }), {});\n};\n\n//# sourceURL=webpack:///./src/prune-keys.js?");

/***/ }),

/***/ "./test/test-idb-data.js":
/*!*******************************!*\
  !*** ./test/test-idb-data.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_data_idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/data/idb */ \"./src/data/idb.js\");\n\n\n(async function () {\n  _src_data_idb__WEBPACK_IMPORTED_MODULE_0__[\"default\"].configure({\n    storeName: \"idb-test\"\n  });\n  await _src_data_idb__WEBPACK_IMPORTED_MODULE_0__[\"default\"].purgeForUser({\n    username: \"dat-user\"\n  });\n\n  __webpack_require__(/*! ../src/data/data-acceptance-tests */ \"./src/data/data-acceptance-tests.js\")(_src_data_idb__WEBPACK_IMPORTED_MODULE_0__[\"default\"]).then(() => console.log(\"done\"));\n})();\n\n//# sourceURL=webpack:///./test/test-idb-data.js?");

/***/ })

/******/ });
});