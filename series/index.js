const dateid = require( "./dateid" );
const { isAbsoluteUri, pathOf } = require( "./uri" );
const { expand, compact } = require( "jsonld" );
const DOC = Symbol( "doc" );
//const OPTIONS = Symbol( "options" );
const STORAGE = Symbol( "storage" );
const BASE = Symbol( "base" );

const clone = x => ( x && typeof x === "object" || typeof x === "function" ) ? JSON.parse( JSON.stringify( x ) ) : x;

function squash( node ) {

    const squashed = clone( node );
    const type = node[ "@type" ];
    if ( type ) {

        delete squashed[ "@type" ];
        squashed.type = type;

    }
    const id = node[ "@id" ];
    if ( id ) {

        delete squashed[ "@id" ];
        squashed.id = id;

    }
    return squashed;

}

const endWithSlash = x => x && !x.endsWith( "/" )
    ? x + "/"
    : x;

class Series {

    /*
        @param {Object} options - where:
            base: a base URL for all relative ids in this document
            ns: a namespace in which to generate ids
            name: a name to use to generate the id (autogenerated if not supplied)
    */
    constructor( options ) {

        const { storage } = options;
        if ( !storage ) throw new Error( "No storage provided" );
        this[ STORAGE ] = storage;

        const base = endWithSlash( options.base );
        this[ BASE ] = base;

        const context = [].concat(

            options.context,
            base && { "@base": base }

        ).filter( x => x);

        const name = options.name || dateid();
        const ns = endWithSlash( options.ns );
        const id = ns ? `${ns}${name}` : name;

        const type = options.type;

        this[ DOC ] = options.details || {

            "@context": context,
            "@id": id,
            "@type": [ "Series", type ].filter( x => x )

        };

    }

    // ids
    get id() {

        const rawId = this[ DOC ][ "@id" ];
        const base = this[ BASE ];
        const id = base ? `${base}${rawId}` : rawId;
        return pathOf( id ).substring( 1 );

    }

    // types
    get type() {

        return clone( this[ DOC ][ "@type" ] );

    }

    // top level props
    set( termOrHash, value ) {

        if ( !termOrHash ) return;
        if ( typeof termOrHash === "object" ) {

            const hash = termOrHash
            for( const term in hash ) {

                this.set( term, hash[ term ] );

            }

        } else {

            const term = termOrHash;
            if ( term.startsWith( "@" ) ) throw new Error( "Terms must not start with @" );
            this[ DOC ][ term ] = clone( value );

        }

    }

    get( term ) {

        return clone( this[ DOC ][ term ] );

    }

    // data index
    removeData( itemOrId ) {

        const id = typeof itemOrId === "object" ? itemOrId.id : itemOrId;
        const index = this[ DOC ].index;
        if ( index && ( id in index ) ) {

            const removed = index[ id ];
            delete index[ id ];
            return removed;

        }

    }

    data( optionsOrId ) {

        if ( typeof optionsOrId === "object" ) {

            const node = clone( optionsOrId );
            const id = node.id || `${endWithSlash( node.ns )}${dateid()}`;
            delete node.id;
            delete node.ns;

            if ( node.type ) {

                node[ "@type" ] = node.type;
                delete node.type;

            }

            const index = this[ DOC ].index || {};
            index[ id ] = node;
            this[ DOC ].index = index;

            return squash( { id, ...node } );

        } else {

            const id = optionsOrId;

            const index = this[ DOC ].index;
            if ( !index ) return undefined;

            const item = index[ id ];
            if ( !item ) return undefined;

            return squash( { id, ...item } );

        }

    }

    // operations
    async save() {

        let bucket = this[ STORAGE ];
        const names = this.id.split( "/" );
        for( const name of names ) {

            bucket = await bucket.bucket( name );

        }
        const details = await bucket.item( "details" );
        await details.content( this[ DOC ] );

    }

    async export() {

        return await compact(

            await expand( this[ DOC ] ),
            {}

        );

    }

    createSeries( options ) {

        const storage = this[ STORAGE ];

        if ( !( isAbsoluteUri( options.ns ) || options.base ) ) {

            const hostId = this.id;
            if ( isAbsoluteUri( hostId ) ) {

                options.base = hostId;

            } else {

                const hostContext = [].concat( this[ DOC ][ "@context" ] );
                const hostBase = hostContext[ 1 ] && hostContext[ 1 ][ "@base" ];
                if ( !hostBase ) throw new Error( `Malformed container - neither base nor id are absolute URIs. Base: ${hostBase}. Id: ${hostId}.` );
                options.base = `${hostBase}${hostId}`;

            }

        }
        return new Series( { storage, ...options } );

    }

    static async resolveBucket( options ) {

        if ( !options.id ) throw new Error( "No id specified" );
        let bucket = await options.storage;
        for( const name of options.id.split( "/" ) )
            bucket = await bucket.bucket( name );
        return bucket;

    }

    static async load( options ) {

        const bucket = await Series.resolveBucket( options );
        if ( !( await bucket.exists() ) ) return undefined;
        const detailsItem = await bucket.item( "details" );
        const details = await detailsItem.content();
        return new Series( { ...options, details } );

    }

    static async delete( options ) {

        const bucket = await Series.resolveBucket( options );
        await bucket.delete();

    }

}

module.exports = function( options ) {

    if ( !( options && options.storage && options.context ) )
        throw new Error( "Invalid options supplied. Expected storage, context (uri)" );
    return {

        createSeries: seriesOptions => new Series( { ...seriesOptions, ...options } ),
        loadSeries: id => Series.load( { id, ...options } ),
        deleteSeries: id => Series.delete( { id, ...options } )

    };

};
