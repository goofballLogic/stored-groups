const dateid = require( "./dateid" );
const { isAbsoluteUri, pathOf } = require( "./uri" );
const { expand, compact } = require( "jsonld" );
const DOC = Symbol( "doc" );
const STORAGE = Symbol( "storage" );
const CONTEXT = Symbol( "context" );
const BASE = Symbol( "base" );

const clone = x => ( x && typeof x === "object" || typeof x === "function" ) ? JSON.parse( JSON.stringify( x ) ) : x;
let documentLoader = null;

function squash( node ) {

    const squashed = clone( node );
    const type = node[ "@type" ];
    if ( type ) {

        delete squashed[ "@type" ];
        squashed.type = type;

    }
    const id = node[ "@id" ];
    if ( id ) {

        delete squashed[ "@id" ];
        squashed.id = id;

    }
    return squashed;

}

const endWithSlash = x => x && !x.endsWith( "/" )
    ? x + "/"
    : x;

class Series {

    /*
        @param {Object} options - where:
            base: a base URL for all relative ids in this document
            ns: a namespace in which to generate ids
            name: a name to use to generate the id (autogenerated if not supplied)
    */
    constructor( options ) {

        const { storage } = options;
        if ( !storage ) throw new Error( "No storage provided" );
        this[ STORAGE ] = storage;

        const base = endWithSlash( options.base );
        this[ BASE ] = base;
        const context = [].concat( options.context || [] );
        if ( base ) {

            const existingBase = [ ...context ].reverse().find(

                c => c && ( typeof c === "object" ) && ( "@base" in c )

            );
            if ( existingBase ) {

                existingBase[ "@base" ] = base;

            } else {

                context.push( { "@base": base } );

            }

        }
        this[ CONTEXT ] = context;

        const name = options.name || dateid();
        const ns = endWithSlash( options.ns );
        const id = ns ? `${ns}${name}` : name;

        const type = options.type;

        this[ DOC ] = options.details || {

            "@context": context,
            "@id": id,
            "@type": [ "Series", type ].filter( x => x )

        };

    }

    // ids
    get id() {

        const rawId = this[ DOC ][ "@id" ];
        const base = this[ BASE ];
        const id = base ? `${base}${rawId}` : rawId;
        return pathOf( id ).substring( 1 );

    }

    // types
    get type() {

        return clone( this[ DOC ][ "@type" ] );

    }

    // top level props
    set( termOrHash, value ) {

        if ( !termOrHash ) return;
        if ( typeof termOrHash === "object" ) {

            const hash = termOrHash
            for( const term in hash ) {

                this.set( term, hash[ term ] );

            }

        } else {

            const term = termOrHash;
            if ( term.startsWith( "@" ) ) throw new Error( "Terms must not start with @" );
            this[ DOC ][ term ] = clone( value );

        }

    }

    get( term ) {

        return clone( this[ DOC ][ term ] );

    }

    // data index
    removeData( itemOrId ) {

        const id = typeof itemOrId === "object" ? itemOrId.id : itemOrId;
        const index = this[ DOC ].index;
        if ( index && ( id in index ) ) {

            const removed = index[ id ];
            delete index[ id ];
            return removed;

        }

    }

    data( optionsOrId ) {

        if ( typeof optionsOrId === "object" ) {

            const node = clone( optionsOrId );
            const id = node.id || `${endWithSlash( node.ns )}${dateid()}`;
            delete node.id;
            delete node.ns;

            if ( node.type ) {

                node[ "@type" ] = node.type;
                delete node.type;

            }

            const index = this[ DOC ].index || {};
            index[ id ] = node;
            this[ DOC ].index = index;

            return squash( { id, ...node } );

        } else {

            const id = optionsOrId;

            const index = this[ DOC ].index;
            if ( !index ) return undefined;

            const item = index[ id ];
            if ( !item ) return undefined;

            return squash( { id, ...item } );

        }

    }

    // operations
    async save() {

        let bucket = this[ STORAGE ];
        const names = this.id.split( "/" );
        for( const name of names ) {

            bucket = await bucket.bucket( name );

        }
        const details = await bucket.item( "details" );
        await details.content( this[ DOC ] );

    }

    async export() {

        const options = documentLoader ? { documentLoader } : null;
        return await compact(

            await expand( this[ DOC ], options ),
            {}

        );

    }

    ensureAbsoluteBaseOrNamespace( options ) {

        // it's already absolute
        if ( options.base || isAbsoluteUri( options.ns ) ) return options;

        const hostId = this.id;
        // use the host id as the base
        if ( isAbsoluteUri( hostId ) ) return { ...options, base: hostId };

        const hostContext = [].concat( this[ DOC ][ "@context" ] );
        const hostBase = hostContext[ 1 ] && hostContext[ 1 ][ "@base" ];
        if ( !hostBase ) throw new Error( `Malformed container - neither base nor id are absolute URIs. Base: ${hostBase}. Id: ${hostId}.` );

        // use the host's base + id as the base
        return { ...options, base: `${hostBase}${hostId}/` };

    }

    createSeries( options ) {

        const storage = this[ STORAGE ];
        const context = clone( this[ CONTEXT ] );
        options = this.ensureAbsoluteBaseOrNamespace( options );
        return new Series( { context, storage, ...options } );

    }

    loadSeries( options ) {

        if ( !options ) throw new Error( "No name provided" );
        if ( options.id ) throw new Error( "Don't provide a series id to Series->loadSeries, use the top-level loadSeries instead. If you are trying to load a nested series by name, pass the name option instead" );

        const storage = this[ STORAGE ];

        const hostBase = this[ BASE ];
        options = this.ensureAbsoluteBaseOrNamespace( options );
        if ( !options.base.startsWith( hostBase ) ) throw new Error( "Not a nested series. Did you mean to call the top-level loadSeries?" );
        options.id = `${options.base}${options.name}`.substring( hostBase.length );
        return Series.load( { storage, ...options } );

    }

    static async resolveBucket( options ) {

        if ( !options.id ) throw new Error( "No id specified" );
        if ( !options.storage ) throw new Error( "No storage provided" );
        let bucket = await options.storage;
        for( const name of options.id.split( "/" ) )
            bucket = await bucket.bucket( name );
        return bucket;

    }

    static async load( options ) {

        const bucket = await Series.resolveBucket( options );
        if ( !( await bucket.exists() ) ) return undefined;
        const detailsItem = await bucket.item( "details" );
        const details = await detailsItem.content();
        return new Series( { ...options, details } );

    }

    static async delete( options ) {

console.log( options );
        const bucket = await Series.resolveBucket( options );
console.log( bucket );
        await bucket.delete();

    }

}

module.exports = function( options ) {

    if ( !( options && options.storage && options.context ) )
    throw new Error( "Invalid options supplied. Expected storage, context (uri)" );
    const { localContextMap } = options;
    if ( localContextMap ) {

        const keys = Object.keys( localContextMap );
        documentLoader = function( url ) {

            const matched = keys.find( key => url.endsWith( key ) );
            if ( matched ) return { document: localContextMap[ matched ] };
            else {

                const err = new Error( `No local context mapping for ${url}` );
                console.error( err );
                throw err;

            }

        };

    }
    return {

        createSeries: seriesOptions => new Series( { ...seriesOptions, ...options } ),
        loadSeries: id => Series.load( { id, ...options } ),
        deleteSeries: id => Series.delete( { id, ...options } )

    };

};
